# 10단계: 웹플럭스란 (WebFlux)

## 목표
- **논블로킹 I/O**, **리액티브 스트림**, **Spring WebFlux의 위치**를 이해한다.
- 이 프로젝트가 이미 WebFlux 위에서 돌아가고 있다는 걸 안다.

---

## 0. 왜 쓰는가?

### 블로킹의 한계

전통적인 Spring MVC는 **요청당 스레드**가 하나 잡히고, DB 호출·HTTP 호출 같은 I/O가 끝날 때까지 그 **스레드를 멈춰 놓는다(블로킹)**. 동시 요청이 많아지면 스레드 수가 늘어나고, 컨텍스트 스위칭·메모리 부담이 커진다.

- **논블로킹**: I/O를 기다리는 동안 **스레드를 놓아 준다**. 다른 요청을 그 스레드로 처리한다. 그래서 **적은 스레드로 많은 동시 요청**을 처리할 수 있다.
- **리액티브**: "데이터가 올 때마다 반응해서 처리한다"는 프로그래밍 모델. **Publisher가 데이터를 흘려보내고**, **Subscriber가 구독해서 처리**하는 방식이다. Java에서는 **Reactive Streams** 표준으로 정의되어 있고, Spring WebFlux는 그 위에 있다.

정리하면, **많은 동시 연결·I/O 바운드**인 API(채팅, 스트리밍, 대량 요청)에서 스레드를 아끼고 확장성을 노리려고 WebFlux(논블로킹 + 리액티브)를 쓴다. "왜 웹플럭스를 쓰는가"를 말할 때는 **논블로킹 I/O**와 **리액티브 스트림**을 한 문장씩 짚어 주면 된다.

---

## 1. 논블로킹 I/O

- **블로킹**: 스레드가 DB/HTTP 응답을 기다리는 동안 **아무 일도 못 하고** 멈춰 있음.
- **논블로킹**: I/O 요청을 보내고 **바로 제어를 반환**. "완료되면 이 콜백 실행해 줘"라고 등록해 두고, 그 스레드는 다른 일을 한다. 완료되면 이벤트 루프·스케줄러가 콜백을 실행한다.
- **효과**: 스레드 수를 크게 늘리지 않아도, I/O 대기 시간 동안 다른 요청을 처리할 수 있어서 **동시 처리량**이 올라간다.

---

## 2. 리액티브 스트림 (Reactive Streams)

- **Publisher**: 데이터(또는 이벤트)를 **발행**하는 쪽. 0개, 1개, N개, 무한히 줄 수 있다.
- **Subscriber**: Publisher를 **구독**하고, `onNext`, `onComplete`, `onError` 로 데이터·완료·에러를 받는다.
- **백프레셔(Backpressure)**: Subscriber가 "몇 개만 더 보내 줘"라고 요청할 수 있어서, 발행 속도가 구독 처리 능력을 넘지 않게 조절할 수 있다.

Java에서는 `org.reactivestreams` 패키지로 인터페이스가 정의되어 있고, **Reactor(Mono, Flux)** 가 그 구현체다. Spring WebFlux는 이 Reactor를 사용한다.

---

## 3. Spring WebFlux의 위치

- **Spring MVC**: 서블릿 스택, 블로킹 I/O, 요청당 스레드.
- **Spring WebFlux**: **논블로킹** 서버(Netty 등) 위에서 동작하고, Controller·Service에서 **Mono/Flux** 를 반환한다. 리액티브 스트림 규약을 따른다.
- **같은 Spring 생태계**이지만, **다른 런타임·프로그래밍 모델**이다. WebFlux를 쓸 때는 **끝까지 논블로킹**으로 가는 게 좋고, 중간에 블로킹 호출(기존 JDBC, 동기 HTTP 등)을 넣으면 이점이 줄어든다.

이 프로젝트는 **spring-boot-starter-webflux** 를 쓰고 있어서, 이미 WebFlux(Netty) 위에서 돌아가며, Controller에서 `Mono<String>` 을 반환하는 구조다.

---

## 4. 실전에서 어떻게 쓰는지

### 4-1. "웹플럭스가 뭐예요?"라고 물었을 때

- **한 문장**: "Spring이 제공하는 논블로킹·리액티브 웹 프레임워크예요. 요청당 스레드를 묶어 두지 않고, Mono/Flux로 비동기 스트림을 다룹니다."
- **세트로**: (1) 논블로킹 I/O로 스레드를 아끼고 동시 처리량을 올린다, (2) 리액티브 스트림(Reactor의 Mono/Flux)으로 데이터 흐름을 선언적으로 다룬다, (3) Spring MVC와 다른 런타임이므로 블로킹 호출을 섞지 않는 게 좋다.

### 4-2. 이 프로젝트에서

- **Controller**: `Mono.just(step10Service.hello())` 처럼 **Mono**를 반환하면 WebFlux가 그걸 구독하고, 결과를 응답으로 쓴다.
- **Service**: 지금은 동기 함수(`hello(): String`)를 쓰고, Controller에서 `Mono.just(...)` 로 감싸도 된다. Step 16부터 Service에서도 `Mono`/`Flux`를 반환하는 패턴을 다룬다.

### 4-3. 실전에서 정리

| 상황 | 어떻게 쓰는지 |
|------|----------------|
| 웹플럭스 설명 | 논블로킹 I/O + 리액티브 스트림(Mono/Flux) + Spring의 비블로킹 웹 스택 |
| 도입 여부 | 동시 연결 많고 I/O 많은 API면 고려, 기존 블로킹 코드 많으면 전환 비용 고려 |
| 코드에서 | Controller/Service에서 Mono·Flux 반환, 블로킹 호출 피하기 |

---

## 5. 주의점

- **블로킹 호출**을 리액티브 체인 안에 넣으면, 그 스레드가 막히기 때문에 논블로킹 이점이 사라진다. DB·HTTP는 **리액티브 드라이버**(R2DBC, WebClient 등)를 쓰는 게 맞다.
- 학습 순서: "웹플럭스란(Step 10)" → Reactor 기초(Mono, Flux) → Controller/Service에서 Mono/Flux 쓰기.

---
