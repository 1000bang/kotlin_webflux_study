# 12단계: 블로킹 vs 논블로킹

## 목표
- **블로킹**: 스레드가 I/O 완료까지 **멈춰 있는** 동작을 이해한다.
- **논블로킹**: I/O를 걸어 두고 **제어를 반환**하고, 완료 시 콜백/다음 단계가 실행되는 방식을 이해한다.
- WebFlux 환경에서 **블로킹 호출을 넣으면 안 되는 이유**와 **subscribeOn**으로 블로킹 작업을 격리하는 방법을 안다.

---

## 1. 블로킹이란

- 스레드가 **DB 조회·HTTP 호출·파일 읽기·Thread.sleep()** 등이 끝날 때까지 **그 자리에서 대기**하는 것.
- 그 동안 그 스레드는 **다른 요청을 처리하지 못한다**. 동시 요청이 많으면 스레드 수가 늘어나고, 컨텍스트 스위칭·메모리 비용이 커진다.
- 전통적인 **동기 JDBC**, **RestTemplate**, **Thread.sleep()** 은 모두 블로킹이다.

---

## 2. 논블로킹이란

- I/O를 **요청만 하고** 곧바로 제어를 반환한다. "완료되면 이 다음 단계 실행해 줘"라고 **콜백·체인**으로 등록해 둠.
- 같은 스레드가 **다른 요청**을 처리할 수 있어서, **적은 스레드로 많은 동시 연결**을 처리할 수 있다.
- **R2DBC**, **WebClient**, **Mono/Flux** 기반 비동기 코드가 논블로킹에 해당한다.

---

## 3. WebFlux에서 블로킹을 쓰면?

- WebFlux는 **소수의 이벤트 루프 스레드**로 요청을 받고, 리액티브 체인이 **논블로킹**으로 이어져야 이점이 있다.
- 리액티브 체인 **안에서** `block()`, 동기 JDBC, `Thread.sleep()` 같은 **블로킹 호출**을 하면, 그 스레드가 막혀서 **다른 요청을 처리하지 못한다**. 동시 처리량이 떨어진다.
- 따라서 **원칙**: Controller/Service 리액티브 경로에서는 블로킹 호출을 하지 않고, DB·외부 호출은 **리액티브 드라이버**(R2DBC, WebClient)로 한다.

---

## 4. 불가피하게 블로킹을 쓸 때: subscribeOn

- 레거시 API·동기 DB를 **당장 리액티브로 바꾸기 어렵다**면, 블로킹 작업만 **별도 스레드 풀**에서 실행하도록 하라.
- **subscribeOn(Schedulers.boundedElastic())**: 구독이 **어느 스레드에서 실행될지**를 지정한다. `boundedElastic()`은 블로킹 작업용 스레드 풀이다. 여기서 블로킹 호출을 하면, Netty 이벤트 루프 스레드는 막히지 않는다.
- 주의: 이렇게 하면 **스레드를 아끼는 이점은 줄어든다**. 가능하면 나중에 R2DBC·WebClient로 전환하는 게 좋다.

---

## 5. 실전에서 어떻게 쓰는지

| 상황 | 어떻게 |
|------|--------|
| "블로킹이 뭐예요?" | 스레드가 I/O 완료까지 멈춰 있는 것. 논블로킹은 I/O 요청 후 제어 반환, 완료 시 콜백/체인 실행. |
| WebFlux에서 블로킹 | 리액티브 체인 안에서 block(), 동기 JDBC, sleep 사용 금지. 스레드가 막혀 이점 상실. |
| 어쩔 수 없이 블로킹 | Mono.fromCallable { blockingCall() }.subscribeOn(Schedulers.boundedElastic()) 로 격리. |

---

## 6. 주의점

- **block()** 은 "지금 이 스레드에서 결과 나올 때까지 기다려"이므로, Netty 스레드에서 호출하면 안 된다.
- **subscribeOn**은 "구독이 일어나는 스레드"를 바꾼다. **publishOn**은 "그 다음 연산부터" 스레드를 바꾼다. 둘 다 쓸 수 있지만, 블로킹 격리할 때는 보통 subscribeOn을 쓴다.
